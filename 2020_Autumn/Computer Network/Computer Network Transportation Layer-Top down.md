# Computer Network Transportation Layer-Top down

## 概述和传输层服务

* 传输层为不同主机上的应用进程之间提供了逻辑通信
* 传输层协议在端系统中实现，运输层将发送应用程序进程接收到的报文转换为传输层分组，分组称为传输层报文段，将应用报文划分为较小的块，并为每块加上传输层首部生成传输层报文段

### 传输层&&网络层

传输层运行于网络层之上，它的性能受制于网络层

### Internet网络层概述

区分几个术语：运输层中，称运输层分组为报文段，实际上，绝大部分文献称TCP的传输层分组为报文段，称UDP分组为数据报

IP称为网际协议，它的模型是尽力而为交付服务

#### UDP和TCP的服务模型

基本的功能：主机间交付扩展到进程间交付，这个过程称为**传输层的多路复用与多路分解**

#### TCP提供的附加服务

* 可靠数据传输
* 拥塞控制，相当于提供给整个Internet的服务

### 多路复用和多路分解

#### 运输层多路复用的要求

* 接收端的套接字（运输层-应用层接口）具有唯一的标识
* 每个报文段要有独特字段指示报文段要交付到的套接字——源端口号-目的端口号
* 周知端口号 0-1023

#### 无连接的多路复用和多路分解

UDP套接字由目的IP和目的端口号标记

源端口号的作用：作为返回地址的一部分

服务器端运行有多个进程，拥有各自的套接字和端口号，网络到达UDP报文段时，接受主机通过检查报文段中的目的端口号，将每个报文段定向分解到相应的套接字

#### 面向连接的多路复用和多路分解

TCP套接字是四元组：源/目的IP，源/目的端口

例子：客户机-服务器模型

* TCP服务器应用程序有一个进程，在12000端口上等待着来自TCP用户的连接建立请求
* TCP创建一个socket并发送一个连接建立请求报文段
* 连接建立请求被发送
* 目的主机接收到连接建立请求，定位到服务器进程，这个进程正在端口12000等待接收连接
* 进程根据四个变量创建socket，目的/源IP，目的/源端口
* 服务器主机上支持多个并行的TCP套接字，每个套接字和一个进程相联系，并由四元组标识每个套接字，当一个TCP报文段到达主机是，所有四个字段，包括源/目的IP，源/目的端口都用来将报文段定向分解至相应的套接字

#### Web服务器与TCP

* 多个浏览器向Web服务器发送报文段，这些报文段的目的端口都是80，初始建立连接报文段承载HTTP请求的报文段都有目的端口80。
* Web服务器为每条连接生成一个新的进程，每个进程都有自己的连接套接字，这些套接字可以收到HTTP请求和发出HTTP响应
* 当前的Web服务器往往使用多线程-单进程的模式，每个套接字其实对应的是服务器上正在运行的一个线程
* 持续HTTP采取一个套接字处理所有请求，非持续HTTP需要产生多个套接字

## 无连接UDP

DNS是使用UDP的应用层协议，不需要执行任何与运行在目的端系统中的UDP实体之间的握手，主机端UDP为此报文添加首部字段，然后将形成的报文段交给网络层，网络层将UDP报文封装在IP数据报中，然后将其发送给一个名字服务器，查询主机中的DNS应用程序等待对该查询的响应，如果没有收到响应，就试图向另一个名字服务器发送该查询或通知调用的应用程序不能获得响应

### 优势：

* 控制传输时间（没有拥塞控制机制）
* 无需连接建立，不会引起建立连接的时延
* 无连接状态
* 分组开销首部小

可以利用应用程序自身建立可靠性机制

### UDP报文段结构

![image-20201111165608567](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201111165608567.png)

* 长度：这里指的是整个报文+数据包头的长度
* 检验和

### 检验和

回卷加法

UDP必须在端到端基础上在运输层提供差错检测

端到端原则：某种功能必须在端到端实现

## 可靠数据传输原理

为上层提供的服务抽象：为上层提供一条逻辑上可靠的信道

### 构造可靠数据传输协议

#### 完全可靠的信道上传输数据

#### 具有比特差错信道的可靠数据传输

组成

* 差错检测机制/编码

* 接收方反馈：肯定确认/否定确认

* 重传

停等协议

处理ACK/NAK受损

* 增加足够的检验和比特，使之能够恢复差错
* 重传分组/冗余
* 增加分组的序号

#### 具有丢包可能的信道上的可靠数据传输

* 增加定时器，响应计时器中断
* 引入冗余数据分组
* 比特交际协议

### 回退N步

#### 发送方

* 上层调用，判断窗口是否是满的
* 收到一个ACK，采取累积确认，直接移动窗口
* 超时事件，重传所有已发送但是尚未确认的分组，认为base分组没有收到，那么之后的分组也没有收到

### 选择重传

#### 发送方

* 从上层收到数据，序号在发送方窗口内就发送，否则缓存后者返回给调用者
* 超时 每个分组拥有自己的逻辑定时器
* 收到ACK，ACK在窗孔欸，SR将确认的分组标记为已接受，如果该分组号等于send_base，窗口向前移动到具有最小序号的未确认分组处

#### 接收方

* 在rcv_base,rcv_base+N-1内的分组被正确接收，收到的分组需要返回一个ACK给发送方，之前该分组没收到过，则缓存该分组，如果分组的序号等于窗口的基序号，就向前移动分组
* 分组即使是重复分组，也需要发送一个ACK
* 其他情况忽略该分组