# 曾建江报告

## 报告讨论的topic

### 趋势和挑战

* 处理器的发展
  * 晶体管数量
  * 单核性能
  * 频率
  * 功耗
  * 处理器核的数量
* 逻辑核的形态
  * 定制化设计
* 指令集的发展 Interface between software and hardware
  * CISC到RISC到VLIW
  * 相互借鉴
* 编译器的发展
  * 单核优化
  * 多核优化
  * 异构优化、超异构优化：后摩尔定律时代，软件灾难，软件为处理器架构优化策略不同
  * 兼容性问题，不同软件核
  * 源码兼容性：不能保证性能相同与代码兼容性两者兼得
* 新的开发模式
  * 所见即所得
  * 协同开发：实时性
  * 智慧化开发
* 编译器关键技术（升腾）
  * super kernel优化技术：编译性能问题
  * 并行编译，ccache优化
  * 算子编译优化和代码生成技术
* 方舟编译器
  * Java静态优化
  * 内存管理

### 设计和实践

#### 关注的问题

* 设计：语法、语义
  * 表达力强
  * 容易使用
  * 不易出错
* 实现：在芯片上运行
  * 运行时间，占用资源
  * 可移植

#### 编译的基本过程

* 源代码(词法解析，语法解析)
* 抽象语法树(语义检查)
* 解释器 or 编译器(代码生成或优化)
* 字节码(虚拟机) or 二进制(处理器)

#### 执行方式

* 解释执行
* 编译执行
* 字节码虚拟机：处理器无关的，运行在虚拟机中，实时编译为字节码，交给机器执行

### 方舟编译器

#### 跨语言墙

* 调用不同语言写成的接口
* 不同语言标识为统一的中间表达

#### Auto-Tuning

* 静态翻译无法获取最优性能
  * 需要参数辅助编译的优化
  * 很难做到软件无关
* 循环展开：复制循环，避免跳转
* 组成
  * Tuning-enable编译器
    * 暴露编译优化参数给外部
    * 平台评估、衡量
  * Search Driver
    * 给出进一步的更优解
    * 搜索驱动
  * Profile
    * 是否性能最优？

### 指令集优化-特定场景

* 并行需要保证一致
* 传统上：自旋锁
* 只抢一次，同时操作
* 一次性原子指令，减少冲突几率

#### 通用编程语言扩展机制

#### 芯片专用性-基于各种应用

特定芯片-特定编译器

统一的指令集中间表示

## 设计的编译知识

* 中间表示
* 抽象语法树
* 编译的过程
* 编译器前端：语法分析，词法分析

## 编译和程序语言对现在业界的影响

* 编译器是高级语言到底层低级语言之间的桥梁
* 不同的程序语言需要开发对应的编译器，编译器和语言的开发是统一的
* 编译器的效率可能导致整个系统的瓶颈，编译器的优化带来的是整个系统的优化

## 现存的编译和编程语言中的问题

* 编译器对二义文法忍受程度较低，导致编译器设计者需要保证不出现二义文法
* 多线程优化和多处理器优化支持不强
* AI编程支持的架构尚未成熟，传统的面向硬件的优化策略可能受限于硬件的发展

## 解答

### 问题一

增加二义文法的容忍程度，可以修改编译前端语法分析的生成策略，使得容忍二义文法。但是对语法的二义性进行分级，使得区分某些二义性避免过于容忍二义性

设置两种模式，一种容忍二义文法，一种不能容忍二义文法，在生成语法树的过程中根据输入改变语法树的结构，比如如下二义文法

```txt
S->S+S|S*S|a
```

对于输入存在二义性a*a+a有两种生成树，此时用户在词法生成文件中可以自定义产生式优先级，以确保使用哪一个产生式进行规约。

对于没有指明二义性优先级的文法，需要说明的是，可以通过一种所谓的统计方法判断使用哪一个产生式进行规约，利用在此之前出现的规约方式预测采取的规约式，然后利用LR1分析方法判断结果的正确性

### 问题二

计算一个矩阵相乘的时候，我们一般的算法时间复杂度为O($n^3$)

![image-20201130014912159](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201130014912159.png)

简单的算法优化基于分治的思想，可以减少时间复杂度，但是仍然高于$n^2$

现在在多处理器集群中采取优化，编译器在语法树上分析出可以并行处理的语句，并加以标记，在实际运行中，将这些任务分配到多个物理计算单元中进行计算，只要划分比较合理，就可以在尽量减少核间开销作用的前提下，实现高并行性

每个并行的部分在前端分析的时候加上一个进程创建命令，创建一个单独的计算进程完成任务，比如为每个数组成员的计算创建一个进程，这样就可以减少时间复杂度为线性时间

![image-20201130015442884](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201130015442884.png)

但是这种优化存在的隐患是可能的无法预测的处理器核之间存在通信的开销以及实际上处理器核的数量需要与问题规模相关，这是我们对于平台无关所不希望的。

可以在并行的任务之间增加一个统计量统计并行任务通信的次数，如果通信次数过高，可以合并这两个任务到一个处理器核上，对于处理器核不足的问题，可以使用多线程虚拟化处理器。