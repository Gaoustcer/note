# C++智能指针

## std::auto_ptr

### basic concept

提升了指针的垃圾收集能力，在auto_ptr对象被销毁时，指针指向的元素被自动销毁。

具有对分配给它们的指针具有所有权的特性：对一个元素拥有所有权的对象负责销毁它指向的元素，并在销毁它时销毁分配给它的内存，析构函数通过delete实现

不会有两个auto_ptr对象拥有相同的元素，在两个auto_ptr对象之间发生复制的时候，所有权被转移，失去所有权的auto_ptr对象不在指向该元素，被设置为空指针

### 存在的风险

* 移动语义通过复制构造函数和赋值运算符实现移动语义，因此按值传递给函数作为参数将会导致实参被销毁
* 使用非数组的delete删除指向的元素，因此无法使用动态分配的数组，而且并不会组织传递给动态数组
* 在标准库上的许多其他类不能很好地发挥作用，因为标准库类假定它们在复制元素项时是复制并非移动

## std::unique

### 基本概念

区分复制语义和移动语义，定义移动的概念，将复制和移动加以区分

转移对象的管理权，需要使用std::move触发移动赋值而不是复制赋值

重载*和-> *返回对指向对象的引用，->返回指针std::unique_ptr为真则代表对象确实有管理的资源

## std::shared_ptr

### 基本概念

多个std::shared_ptr可以管理同一对象，共享对象的所有权是利用引用计数器实现

* 拷贝shared_ptr，引用计数值+1
* unique()方法检查对象是否被唯一拥有，use_count()返回引用计数值
* shared_ptr共享的引用计数下降到0的时候，对象自动被析构
* 可以从唯一指针创建共享指针
* 风险：互锁导致资源永远无法被释放

## std::weak_ptr

### 基本概念

解决shared_ptr的死锁



存储器分层的意义

为什么Von机不能同时访问数据和指令

数据和指令在内存中如何区分