# 算法-摊还分析

## 基本思想

求数据结构中一个操作序列中所执行的所有操作平均时间，可以发现，某些操作的时间代价比较大但是平均下来操作的时间开销比较小

### 基本分析方法

* 聚合分析
* 核算法
* 势能法

## 聚合分析

### 栈操作

#### 问题描述

一个栈中，出栈、入栈操作的时间复杂度为O(1)

增加一个新操作，MULTIPOP(S,k)，删除栈顶k个对象，栈中内容小于k个，则弹出整个栈的内容

#### 分析

现在有个操作序列，长度为n，有push，pop和MULTIPOP组成

执行n个操作组成的操作序列时间复杂度为O(n)，因为一个元素最多只能被弹出栈一次

这样，每个栈操作的摊还代价为O(1)

### 二进制计数器递增

用k位二进制存储计数器，可以得到以下结论

* 最低位每次递增都会改变
* 次低位每隔2次改变
* 次次地委每隔4次改变

总共需要改变的位数为

$\sum\limits _1^{k-1}\lfloor n\div (2^i)\rfloor \leq 2\times n$

时间代价为O(1)

## 核算法

赋予一个操作的费用：摊还代价

摊还代价超过实际代价：差额存入数据结构中的特定对象，称为信用，信用支付差额

$\sum \limits _{i=1}^n c$<sup>^</sup><sub>i</sub>$\geq$$\sum \limits _{i=1}^{n}c$<sub>i</sub>

需要保证最终摊还代价大于实际代价

### 栈操作

#### 操作的实际代价c<sub>i</sub>

* PUSH	1
* POP	   1
* MULTIPOP     min(k,s)

#### 操作的摊还代价

* PUSH     2
* POP       0
* MULTIPOP   0

最多弹出的元素个数不会超过PUSH进栈的元素个数

### 二进制计数器

#### 实际的操作代价

每次递增翻转的位数

#### 摊还代价

置位操作：摊还代价为2(0->1)

复位操作：摊还代价为0

## 势能法

预付代价：势能

势能释放：支付未来操作的代价

### 工作原理

* 对初始数据结构D<sub>0</sub>进行n个操作
* 每个操作的实际代价为c<sub>1</sub>,c<sub>2</sub>,c<sub>3</sub>...c<sub>n</sub>
* D<sub>i</sub>为在数据结构D<sub>i-1</sub>上执行第i个操作得到的数据结构
* 势函数$\Phi$将每个数据结构D<sub>i</sub>映射到一个实数$\Phi$(D<sub>i</sub>)
* 定义一个操作的摊还代价c<sup>^</sup><sub>i</sub>=c<sub>i</sub>+$\Phi$(D<sub>i</sub>)-$\Phi$(D<sub>i-1</sub>),每个操作的摊还代价=实际代价+势能变化
* 总的摊还代价$$\sum \limits _{i=1}^n$$ c<sub>i</sub> <sup>^</sup>=$$\sum \limits _{i=1}^n c$$<sub>i</sub>+$\Phi$(D<sub>n</sub>)-$\Phi$(D<sub>0</sub>)
* 定义初始的势函数为0，证明后续的势函数为正数

